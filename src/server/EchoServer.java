package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.IOException;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {	//Class variables *************************************************	/**	 * The default port to connect on.	 */	final public static int DEFAULT_PORT = 5555;	//Instance variables **********************************************	ChatIF serverUI;	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		super(port);		this.serverUI = serverUI;	}	//Instance methods ************************************************	/**	 * This method handles all data coming from the UI            	 *	 * @param message The message from the UI.    	 */	public void handleMessageFromServerUI(String message)	{		if(message.startsWith("#")){			handleServerCommand(message);		}		else{			serverUI.display(message);			this.sendToAllClients("Server MSG > " + message);		}	}	private void handleServerCommand(String message) {		String[] tab = message.split(" ");		switch(tab[0]) {		case("#quit"):			System.exit(0);		break;		case("#stop"):			this.stopListening();		break;		case("#close"):			try {				this.close();			} 		catch (IOException e) {			e.printStackTrace();		}		break;		case("#setport"):			if(!this.isListening()) {				if(tab.length > 1) {					int port = Integer.parseInt(tab[1]);					this.setPort(port);					serverUI.display("New port is " + this.getPort());				}				else {					serverUI.display("Missing port argument !");				}			}		break;		case("#start"):			if(!this.isListening()) {				try {					this.listen();				}				catch (IOException e) {					e.printStackTrace();				}			}		break;		case("#getport"):			serverUI.display(Integer.toString(this.getPort()));		break;		default:			serverUI.display("Invalid command !");			break;		}	}	private void handleClientCommand(String message, ConnectionToClient client) {		String[] tab = message.split(" ");		switch(tab[0]) {		case("#logoff"):			try {				client.close();				serverUI.display("Connection to the client closed !");			} 			catch (IOException e) {				e.printStackTrace();			}			break;		case("#login"):			client.setInfo("id", tab[1]);		default:			serverUI.display("Invalid command !");			break;		}	}	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	@Override	public void handleMessageFromClient (Object msg, ConnectionToClient client)	{		if(msg.toString().startsWith("#")) {			handleClientCommand(msg.toString(), client);		}		else {			serverUI.display("Client "+(String) client.getInfo("id") + " > " + msg);			this.sendToAllClients(msg);		}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	@Override	protected void serverStarted()	{		serverUI.display("Server listening for connections on port " + getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	@Override	protected void serverStopped()	{		serverUI.display("Server has stopped listening for connections.");	}	//Class methods ***************************************************	/**	 * Hook method called each time a new client connection is	 * accepted. The default implementation does nothing.	 * @param client the connection connected to the client.	 */	@Override	protected void clientConnected(ConnectionToClient client) {		serverUI.display("New client connection");	}	/**	 * Hook method called each time a client disconnects.	 * The default implementation does nothing. The method	 * may be overridden by subclasses but should remains synchronized.	 *	 * @param client the connection with the client.	 */	@Override	synchronized protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("One client disconnected");	}	/**	 * Hook method called each time an exception is thrown in a	 * ConnectionToClient thread.	 * The method may be overridden by subclasses but should remains	 * synchronized.	 *	 * @param client the client that raised the exception.	 * @param Throwable the exception thrown.	 */	@Override	synchronized protected void clientException(			ConnectionToClient client, Throwable exception) {		clientDisconnected(client);		exception.printStackTrace();	}}//End of EchoServer class